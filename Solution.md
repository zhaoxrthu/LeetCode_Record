#**LeetCode解题思路记录**
---

##1.两数之和
&ensp;&ensp;&ensp;&ensp;非常经典的问题了，通过使用哈希表空间换时间使得复杂度从$O(n^2)$降低到了$O(n)$：第一遍扫描将n值作为哈希表的key值，由于题意需要返回下标因而将下标作为item值赋给key值。第二遍扫描时先求出b = target - a，再从哈希表中查找是否存在key值为b的(key, item)对。另外，由于题目要求同一数据不得使用两次，因此还需要检查a和b的下标不一致。

---
##2.两数相加
&ensp;&ensp;&ensp;&ensp;除了使用了链表，实际上和普通的进位加法没有区别。要注意的是通过三目运算符的使用简化了代码，不需要区分两条链表长度一致或不一致的情况。

---
##3.无重复字符的最长子串

---
##7.整数反转
&ensp;&ensp;&ensp;&ensp;正常不断做余取整再反过来累加即可，使用python的话还可以取巧先转化用str()转化为字符串然后翻转[::-1]再用int()变回数字的方法。当然要注意符号和int32溢出的问题。

---
##8.字符串转换整数(atoi)
&ensp;&ensp;&ensp;&ensp;实际上是一个有限状态机的问题。最正常的方法就是老老实实画出状态转移图，然后写出一堆臃肿的代码，另外要注意INT_MIN <= ans <= INT_MAX的边界问题。<br/>
&ensp;&ensp;&ensp;&ensp;一个使用正则表达式来一行解决问题的奇技淫巧：
>max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2^31 - 1), -2^31)

---
##9.回文数
&ensp;&ensp;&ensp;&ensp;负数一定不是回文数，正数做余取整再反过来累加作比较。python的话同样可以字面意义上的比较是否“回文”。

---
##11.盛最多水的容器
&ensp;&ensp;&ensp;&ensp;非常机智的思路。使用i, j双指针分别指向开头和结尾，表示目前使用的两块木板，那么易知当前的容量为min(h[i], h[j]) *  (j - i)。现在考虑下一步如何搜索：不放假设h[i] < h[j], 显然此时S = h[i] * (j - i)。如果此时移动j = j - 1， 那么下一个面积只有可能更小：S = min(h[i], h[i] - 1) * (j - i - 1)，不可能是需要搜索的值，因此，应该移动i = i + 1。

---
##13.罗马数字转整数
&ensp;&ensp;&ensp;&ensp;取巧。直接计数即可，对于特殊情况相当于多加了两倍的值，从累加结果中减去即可。

---
##55.跳跃游戏
&ensp;&ensp;&ensp;&ensp;由于对于每一个位置i，可以从该位置往后走(1, 2, ……， nums[i]）步，因此从当前位置往后（即[i, i + nums[i]]）的位置都可以到达。只需要遍历，更新最远距离即可。

---
##406.根据身高重建队列
&ensp;&ensp;&ensp;&ensp;因为插入身高低的人对于身高高的人的排序无影响，所以应该对k排序再对h排序。对于k==0的人来说，直接按身高进行排序即可；接下来，对于递增的k，分别进行排序：计数当前队列中身高高于或等于的人数，找到合适的位置后插入即可。该题的另一个重点是python类对于运算符的重载：
>        class cmp():
            def __init__(self, array):
                self.v = array
            def __gt__(self, other):
                return self.v[1] > other.v[1] or \
					   self.v[1] == other.v[1] and self.v[0] > other.v[0]

&ensp;&ensp;&ensp;&ensp;该段代码重载了>(gt, great than)运算符。

---
##477.汉明距离总和
&ensp;&ensp;&ensp;&ensp;对于统计之后的二进制中的每一位，如果一共有m位1和n位0，那么显然这一位上造成的汉明距离和位m*n。因此只需要统计所有位（因为10^9<2^36，取M[36]即可）再累加各位上的乘积即可。

---
##495.提莫攻击
&ensp;&ensp;&ensp;&ensp;维护一个当前负面状态结束时间fT，当下一时间长于fT时，结果直接加上duration；否则相当于延长了一个时间t[i] - t[i-1]。

---
##525.连续数组
&ensp;&ensp;&ensp;&ensp;用一个flag记录当前1比0多的个数，并将首次出现的flag值记录在一个哈希表（或者数组）中，当flag第n次出现时更新最长距离re = max(re, i - M[flag])。记得将M[0]初始化为-1。