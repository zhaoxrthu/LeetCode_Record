#**LeetCode解题思路记录**
---

##1.两数之和
&ensp;&ensp;&ensp;&ensp;非常经典的问题了，通过使用哈希表空间换时间使得复杂度从$O(n^2)$降低到了$O(n)$：第一遍扫描将n值作为哈希表的key值，由于题意需要返回下标因而将下标作为item值赋给key值。第二遍扫描时先求出b = target - a，再从哈希表中查找是否存在key值为b的(key, item)对。另外，由于题目要求同一数据不得使用两次，因此还需要检查a和b的下标不一致。

---
##2.两数相加
&ensp;&ensp;&ensp;&ensp;除了使用了链表，实际上和普通的进位加法没有区别。要注意的是通过三目运算符的使用简化了代码，不需要区分两条链表长度一致或不一致的情况。

---
##3.无重复字符的最长子串

---
##7.整数反转
&ensp;&ensp;&ensp;&ensp;正常不断做余取整再反过来累加即可，使用python的话还可以取巧先转化用str()转化为字符串然后翻转[::-1]再用int()变回数字的方法。当然要注意符号和int32溢出的问题。

---
##8.字符串转换整数(atoi)
&ensp;&ensp;&ensp;&ensp;实际上是一个有限状态机的问题。最正常的方法就是老老实实画出状态转移图，然后写出一堆臃肿的代码，另外要注意INT_MIN <= ans <= INT_MAX的边界问题。<br/>
&ensp;&ensp;&ensp;&ensp;一个使用正则表达式来一行解决问题的奇技淫巧：
>max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2^31 - 1), -2^31)

---
##9.回文数
&ensp;&ensp;&ensp;&ensp;负数一定不是回文数，正数做余取整再反过来累加作比较。python的话同样可以字面意义上的比较是否“回文”。

---
##11.盛最多水的容器
&ensp;&ensp;&ensp;&ensp;非常机智的思路。使用i, j双指针分别指向开头和结尾，表示目前使用的两块木板，那么易知当前的容量为min(h[i], h[j]) *  (j - i)。现在考虑下一步如何搜索：不放假设h[i] < h[j], 显然此时S = h[i] * (j - i)。如果此时移动j = j - 1， 那么下一个面积只有可能更小：S = min(h[i], h[i] - 1) * (j - i - 1)，不可能是需要搜索的值，因此，应该移动i = i + 1。